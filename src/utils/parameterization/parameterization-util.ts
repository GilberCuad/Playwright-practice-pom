import { Locator, Page } from "@playwright/test";
import { IBasicDataPage } from "../../interfaces/base-data-page";
import { IConnectionDataPage } from "../../interfaces/connection-data-page";
import { IConfigurationDataPage } from "../../interfaces/configuration-data-page";
import { LocatorsParameterization } from "../../pages/parameterization/parameterization-locators-page";
import { faker } from "@faker-js/faker";
import { MessageUtilPage } from "../Message/message-util";
import { BaseParameterization } from "../../pages/parameterization/parameterization-base-page";
import { parameterizationConfig } from '../config/constants';

/**
 * The `ParameterizationBasicDataUtil` class in TypeScript defines methods for generating and inserting basic data with validations.
 * @author Gilber Cuadrado
 * @since 21/10/2024
 * @version 1.0
 */
export class ParameterizationBasicDataUtil extends BaseParameterization {
  protected basicDataPage: IBasicDataPage;

  /**
   * The constructor initializes a BasicData page within a given Page object.
   * @param {IBasicDataPage} basicDataPage -  The instance that implements the `IBasicDataPage` interface.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  constructor(page: Page, basicDataPage: IBasicDataPage) {
    super(page);
    this.basicDataPage = basicDataPage;
  }

  /**
   * The Method `generateBasicData` asynchronously generates basic data including name, description,
   * radio selector, and a random value.
   * @returns The `generateBasicData` Method returns an object with the following properties:
   * - `nameValue`: a string representing a randomly generated full name truncated to 100 characters.
   * - `descriptionValue`: a string representing a randomly generated paragraph of text truncated to 500
   * characters.
   * - `radioSelector`: a string representing a randomly selected radio button selector.
   * - `randomValue`: a string representing the randomly selected
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  async generateBasicData(): Promise<{
    nameValue: string;
    descriptionValue: string;
    radioSelector: string;
  }> {
    let radioValuesType: string[];
    let randomKey: any;
    let randomValue: any;
    let nameValue: string;
    let descriptionValue: string;
    let radioSelector: string;

    radioValuesType = Object.keys(parameterizationConfig.basicData.radioButtonTypeId);
    randomKey = radioValuesType[Math.floor(Math.random() * radioValuesType.length)];
    randomValue = parameterizationConfig.basicData.radioButtonTypeId[randomKey];
    radioSelector = `${randomValue}`;
    nameValue = faker.person.fullName().substring(0, 100);
    descriptionValue = faker.lorem.paragraph().substring(0, 500);

    if (!randomValue) {
      throw new Error(
        `There is a problem with locators, the random value for randomKey is:  ${randomKey}`
      );
    }

    return { nameValue, descriptionValue, radioSelector };
  }

  /**  
   * The above TypeScript code defines an asynchronous Method `performInsertionBasicData` that
  generates basic data using the `generateBasicData` method. It then extracts the values for
  `nameValue`, `descriptionValue`, `radioSelector`, and `randomValue` from the generated data.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  async performInsertionBasicData(): Promise<void> {
    const { nameValue, descriptionValue, radioSelector } =
      await this.generateBasicData();

    if (nameValue.length < 10) {
      throw new Error(
        "The name generated by faker is less than 10, rerun the test"
      );
    }

    await this.basicDataPage.performInsertionBasicData({
      nameValue: nameValue,
      descriptionValue: descriptionValue,
      type: radioSelector,
    });
  }

  /**
   * The Method `performLengthMinimumField` asynchronously sets the length of a field on a basic data
   * page.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  async performLengthMinimumField(): Promise<void> {
    await this.basicDataPage.lengthField({
      nameValue: MessageUtilPage.dataBasic.messageMinimumFieldName,
      descriptionValue: MessageUtilPage.dataBasic.messageMinimumFieldDescription,
    });
  }

  /**
   * The Method `performLengthMaximumField` asynchronously sets the length of a field on a basic data
   * page.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  async performLengthMaximumField(): Promise<void> {
    await this.basicDataPage.lengthField({
      nameValue: MessageUtilPage.dataBasic.messageMaximumFieldName,
      descriptionValue: MessageUtilPage.dataBasic.messageMaximumFieldDescription,
    });
  }

  /**
   * This TypeScript Method asynchronously performs validation and returns a button based on generated
   * basic data.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  async performValidationReturnButton(): Promise<void> {
    const { nameValue, descriptionValue, radioSelector } =
      await this.generateBasicData();

    await this.basicDataPage.performValidationReturnButton({
      nameValue: nameValue,
      descriptionValue: descriptionValue,
      type: radioSelector,
    });
  }

  /**
   * The Method `performLoginFieldRequireUtil` asynchronously generates basic data and then performs a
   * login field requirement using the generated data.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  async performFieldRequireUtil(): Promise<void> {
    const { nameValue } = await this.generateBasicData();

    await this.basicDataPage.performFieldRequire({
      nameValue: nameValue,
    });
  }
}

/**
 * The `ParameterizationConnectionDataUtil` class in TypeScript manages connection data for a page
object, with methods for submitting, validating max length, min length, and required fields
 * @author Gilber Cuadrado
 * @since 21/10/2024
 * @version 1.0
 */

export class ConnectionDataUtil extends BaseParameterization {
  protected connectionDataPage: IConnectionDataPage
  /**
   * The constructor initializes a new ConnectionData object with the given Page object.
   * @param {Page} page - The `page` parameter is an instance of the `Page` class.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  constructor(page: Page, connectionDataPage: IConnectionDataPage) {
    super(page);
    this.connectionDataPage = connectionDataPage;
  }

  /**
   * The Method `submitFormConnectionData` asynchronously submits connection data for insertion.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  async submitFormConnectionData(): Promise<void> {
    await this.connectionDataPage.performInsertionConnectionData({
      host: MessageUtilPage.connectionData.valueTestHostInput,
      port: MessageUtilPage.connectionData.valueTestPortInput,
      user: MessageUtilPage.connectionData.valueTestUserInput,
      password: MessageUtilPage.connectionData.valueTestPasswordInput,
      origin: MessageUtilPage.connectionData.valueTestOriginInput,
      destination: MessageUtilPage.connectionData.valueTestDestinationInput,
    });
  }
  /**
   * The Method `validateMaxLength` asynchronously inserts connection data with maximum length
   * values.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */
  async validateMaxLength() {
    await this.connectionDataPage.performInsertionConnectionData({
      host: MessageUtilPage.connectionData.valueMaxHostInput,
      port: MessageUtilPage.connectionData.valueMaxPortInput,
      user: MessageUtilPage.connectionData.valueMaxUserInput,
      password: MessageUtilPage.connectionData.valueMaxPasswordInput,
      origin: MessageUtilPage.connectionData.valueMaxOriginInput,
      destination: MessageUtilPage.connectionData.valueMaxDestinationInput,
    });
  }

  /**
   * The Method `validateMinLength` asynchronously inserts connection data with minimum length values.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  async validateMinLength() {
    await this.connectionDataPage.performInsertionConnectionData({
      host: MessageUtilPage.connectionData.valueMinHostInput,
      port: MessageUtilPage.connectionData.valueMinPortInput,
      user: MessageUtilPage.connectionData.valueMinUserInput,
      password: MessageUtilPage.connectionData.valueMinPasswordInput,
      origin: MessageUtilPage.connectionData.valueMinOriginInput,
      destination: MessageUtilPage.connectionData.valueMinDestinationInput,
    });
  }

  /**
   * The `validateFieldRequire` Method asynchronously validates required fields in a TypeScript class.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  async validateFieldRequire() {
    await this.connectionDataPage.validateRequiredFields({
      host: MessageUtilPage.connectionData.valueTestHostInput,
      port: MessageUtilPage.connectionData.valueTestPortInput,
      user: MessageUtilPage.connectionData.valueTestUserInput,
      password: MessageUtilPage.connectionData.valueTestPasswordInput,
      origin: MessageUtilPage.connectionData.valueTestOriginInput,
      destination: MessageUtilPage.connectionData.valueTestDestinationInput,
    });
  }
}

/**
 * The ConfigurationDataUtil class in TypeScript handles generating random configuration data and
performing validations for form fields.
 * @author Gilber Cuadrado
 * @since 21/10/2024
 * @version 1.0
 */

export class ConfigurationDataUtil extends BaseParameterization {
  protected configurationData: IConfigurationDataPage;

  /**
   * The constructor initializes a new ConnectionData object with the given Page object.
   * @param {Page} page - The `page` parameter is an instance of the `Page` class.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  constructor(page: Page, configurationData: IConfigurationDataPage) {
    super(page);
    this.configurationData = configurationData;
  }

  /**
   * Method to randomly generate a radio button option on the configuration data page
   * @returns The `generateBasicData` Method returns an option for the radio selector.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  async generateConfigurationRandom(): Promise<{ radioSelector: string }> {
    let radioValuesType: string[];
    let randomKey: any;
    let radioId: any;
    let radioSelector: string;

    radioValuesType = Object.keys(parameterizationConfig.configurationData.radioButtonType);
    randomKey = radioValuesType[Math.floor(Math.random() * radioValuesType.length)];
    radioId = parameterizationConfig.configurationData.radioButtonType[randomKey];
    radioSelector = `${radioId}`;

    return { radioSelector };
  }
  /**
   * Method for randomly generating a button option being active or inactive
   * @returns The `generateStateRandom` Method returns an option for the button state.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  async generateStateRandom(): Promise<{ buttonIdSelector: string }> {
    let buttonValueState: string[];
    let randomValue: any;
    let buttonIdSelector: any;

    buttonValueState = Object.keys(parameterizationConfig.configurationData.radioButtonTypeIdState);
    randomValue = buttonValueState[Math.floor(Math.random() * buttonValueState.length)];
    buttonIdSelector = parameterizationConfig.configurationData.radioButtonTypeIdState[randomValue];

    return { buttonIdSelector };
  }

  /**
   * Method in charge of sending the required data for configuration data where a method is called from page that performs the actions.
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  async submitFormConfigData(): Promise<void> {
    const { radioSelector } = await this.generateConfigurationRandom();
    const { buttonIdSelector } = await this.generateStateRandom();

    await this.configurationData.performInsertionConfigurationData({
      radioSelectorValue: radioSelector,
      buttonSelectorValue: buttonIdSelector,
      regexValue: MessageUtilPage.configData.valueInputRegex,
    });
  }

  /**
   * Method lengthMinValidation is in charge of sending data for validation of minimum lengths
   * @author Gilber Cuadrado
   * @since 28/10/2024
   * @version 1.0
   */

  async lengthMinValidation(): Promise<void> {
    await this.configurationData.performLengthValidation({
      regexValue: MessageUtilPage.configData.valueLengthMinRegexInput,
    });
  }

  /**
   * Method lengthMaxValidation is in charge of sending data for validation of maximum lengths
   * @author Gilber Cuadrado
   * @since 28/10/2024
   * @version 1.0
   */

  async lengthMaxValidation(): Promise<void> {
    await this.configurationData.performLengthValidation({
      regexValue: MessageUtilPage.configData.valueLengthMaxRegexInput,
    });
  }

  /**
   * Method requireField is in charge of sending data for the validation of mandatory fields
   * @author Gilber Cuadrado
   * @since 28/10/2024
   * @version 1.0
   */

  async requireField(): Promise<void> {
    await this.configurationData.performRequireFieldValidation({
      regexValue: MessageUtilPage.configData.valueInputRegex,
    });
  }
}

/**
 * The `SchedulePeriodicityUtil` class in TypeScript provides methods for generating random scheduling
periodicity options such as minutes, hourly, daily, weekly, monthly, and yearly.
 * @author Gilber Cuadrado
 * @since 21/10/2024
 * @version 1.0
 */

export class SchedulePeriodicityUtil extends BaseParameterization {
  protected buttonCreate: Locator;
  protected beginsToHours: Locator;
  protected beginsToMinutes: Locator;
  protected minuteSelect: Locator;
  protected eachHourSelect: Locator;
  protected dayCheckbox: Locator[];
  protected optionsPeriodicity: Locator[];
  protected readonly monthFirstRowSelectDay: Locator;
  protected readonly monthFistRowSelectMonth: Locator;
  protected readonly monthSecondRowSelectSequence: Locator;
  protected readonly monthSecondRowSelectDaysWeek: Locator;
  protected readonly monthSecondRowSelectMonth: Locator;
  protected readonly yearlyFirstRowSelectMonth: Locator;
  protected readonly yearlyFirstRowSelectDay: Locator;
  protected readonly yearlySecondRowSelectSequence: Locator;
  protected readonly yearlySecondRowSelectDayWeek: Locator;
  protected readonly yearlySecondRowSelectMonth: Locator;

  /**
   * The constructor initializes various locators and elements for program periodicity settings on a web page.
   * @param {Page} page - The `page` parameter in the constructor is an object that represents the web
   * page being interacted with in the code. It likely contains methods and properties for locating and
   * interacting with elements on the page, such as finding elements by CSS selectors or XPath.
   * @author Gilber Cuadrado
   * @since 28/10/2024
   */
  constructor(page: Page) {
    super(page);
    this.buttonCreate = page.locator(LocatorsParameterization.programPeriodicity.buttonCreate);
    this.beginsToHours = page.locator(LocatorsParameterization.programPeriodicity.beginTo.beginToHour);
    this.beginsToMinutes = page.locator(LocatorsParameterization.programPeriodicity.beginTo.beginMinutes);
    this.minuteSelect = page.locator(LocatorsParameterization.programPeriodicity.minutes.minutesSelect);
    this.eachHourSelect = page.locator(LocatorsParameterization.programPeriodicity.everyHour.eacHoursSelect);

    this.monthFirstRowSelectDay = page.locator(LocatorsParameterization.programPeriodicity.monthly.monthFirstRowSelectDay);
    this.monthFistRowSelectMonth = page.locator(LocatorsParameterization.programPeriodicity.monthly.monthFistRowSelectMonth);
    this.monthSecondRowSelectSequence = page.locator(LocatorsParameterization.programPeriodicity.monthly.monthSecondRowSelectSequence);
    this.monthSecondRowSelectDaysWeek = page.locator(LocatorsParameterization.programPeriodicity.monthly.monthSecondRowSelectDaysWeek);
    this.monthSecondRowSelectMonth = page.locator(LocatorsParameterization.programPeriodicity.monthly.monthSecondRowSelectMonth);

    this.yearlyFirstRowSelectMonth = page.locator(LocatorsParameterization.programPeriodicity.yearly.yearlyFistRowOfEachMonthSelect);
    this.yearlyFirstRowSelectDay = page.locator(LocatorsParameterization.programPeriodicity.yearly.yearlyFistRowOfEachDaySelect);
    this.yearlySecondRowSelectSequence = page.locator(LocatorsParameterization.programPeriodicity.yearly.yearlySecondRowSequenceSelect);
    this.yearlySecondRowSelectDayWeek = page.locator(LocatorsParameterization.programPeriodicity.yearly.yearlySecondRowDayWeekSelect);
    this.yearlySecondRowSelectMonth = page.locator(LocatorsParameterization.programPeriodicity.yearly.yearlySecondRowMonthsSelect);

    this.dayCheckbox = this.initializeDayCheckboxes(page);
    this.optionsPeriodicity = this.initializeOptionsPeriodicity(page);
  }


  /**
   * The getRandomValue method generates a random number within a specified range and returns it as a
   * string.
   * @param {number} max - The `max` parameter in the `getRandomValue` method represents the maximum
   * value that the random number generated should not exceed.
   * @param [min=1] - The `min` parameter in the `getRandomValue` method is the minimum value that you
   * want the random number to be generated from. If `min` is not provided when calling the method, it
   * defaults to 1.
   * @returns A random number between the specified `min` and `max` values, converted to a string.
   * @author Gilber Cuadrado
   * @since 28/10/2024
   */
  private getRandomValue(max: number, min = 1): string {
    return (Math.floor(Math.random() * (max - min + 1)) + min).toString();
  }




  /**
   * The method selectRandomOption selects a random option based on a given locator and value.
   * @param {Locator} locator - The `locator` parameter is a reference to an element on the web page
   * that you want to interact with. It could be an element identified by its CSS selector, XPath, text
   * content, or other attributes. In the `selectRandomOption` method, the `locator.click()` method is
   * used to
   * @param {string} randomValue - The `randomValue` parameter is a string that is used to generate a
   * regular expression pattern to match a specific text value on the page. This value is then used to
   * locate and click on an element with that text value.
   * @author Gilber Cuadrado
   * @since 28/10/2024
   */
  private async selectRandomOption(locator: Locator, randomValue: string): Promise<void> {
    await locator.click();
    const regex = new RegExp(`^${randomValue}$`);
    await this.page.locator(`text=${regex}`).click();
  }



  /**
   * The method initializes an array of locators for checkboxes representing days of the week on a
   * given page.
   * @param {Page} page - The `page` parameter is an object that represents the page where the
   * checkboxes are located. It is used to create locators for each day of the week checkboxes on that
   * page.
   * @returns An array of Locator objects representing checkboxes for each day of the week (Monday to
   * Sunday) on the provided page.
   * @author Gilber Cuadrado
   * @since 28/10/2024
   */

  private initializeDayCheckboxes(page: Page): Locator[] {
    const { weekly } = LocatorsParameterization.programPeriodicity;
    return [
      page.locator(weekly.mondayCheck),
      page.locator(weekly.tuesdayCheck),
      page.locator(weekly.wednesdayCheck),
      page.locator(weekly.thursdayCheck),
      page.locator(weekly.fridayCheck),
      page.locator(weekly.saturdayCheck),
      page.locator(weekly.sundayCheck),
    ];
  }



  /**
   * The method initializes options for periodicity on a page using specified locators.
   * @param {Page} page - The `page` parameter in the `initializeOptionsPeriodicity` method is of type
   * `Page`, which is likely a class or interface representing a web page or a section of a web page in
   * the context of the code you provided.
   * @returns An array of Locator objects representing different options for program periodicity, such as
   * minutes, each hour, daily, weekly, monthly, and yearly.
   * @author Gilber Cuadrado
   * @since 28/10/2024
   */
  private initializeOptionsPeriodicity(page: Page): Locator[] {
    const { optionsPeriodicity } = LocatorsParameterization.programPeriodicity;
    return [
      page.locator(optionsPeriodicity.minutesOption),
      page.locator(optionsPeriodicity.eachHourOption),
      page.locator(optionsPeriodicity.diaryOption),
      page.locator(optionsPeriodicity.weeklyOption),
      page.locator(optionsPeriodicity.monthlyOption),
      page.locator(optionsPeriodicity.yearlyOption),
    ];
  }



  /**
   * The method selectMinutesRandom selects a random minute value from 0 to 59, sets it in a select
   * element, and then clicks a button.
   * @author Gilber Cuadrado
   * @since 29/10/2024
   */
  async selectMinutesRandom(): Promise<void> {
    const randomMinute = this.getRandomValue(59);
    await this.selectRandomOption(this.minuteSelect, randomMinute);
    await this.buttonCreate.click();
  }


  /**
   * The `selectStartTime` method asynchronously selects random hours and minutes for a start time.
   * @returns An object is being returned with two properties: "hours" and "minutes", each containing a
   * string value.
   * @author Gilber Cuadrado
   * @since 29/10/2024
   */

  async selectStartTime(): Promise<{ hours: string, minutes: string }> {
    const hours = this.getRandomValue(23);
    const minutes = this.getRandomValue(59);

    await this.selectRandomOption(this.beginsToHours, hours);
    await this.selectRandomOption(this.beginsToMinutes, minutes);
    return { hours, minutes };
  }

  /**
   * The `selectEachHour` method asynchronously selects random hours and minutes for a start time.
   * @author Gilber Cuadrado
   * @since 29/10/2024
   */

  async selectEachHour(): Promise<void> {
    const randomHour = this.getRandomValue(23);
    await this.selectRandomOption(this.eachHourSelect, randomHour);
    await this.selectStartTime();
    await this.buttonCreate.click();
  }

  /**
   * The `dataDiary` method generates the random values and performs the actions on the page in the diary option of the parameter module
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  async dataDiary(): Promise<void> {
    let radioValuesType: string[];
    let randomValue: any;
    let radioId: any;
    let radioSelector: string;

    radioValuesType = Object.keys(parameterizationConfig.radioButtonTypeId);
    randomValue = radioValuesType[Math.floor(Math.random() * radioValuesType.length)];
    radioId = parameterizationConfig.radioButtonTypeId[randomValue];
    radioSelector = `${radioId}`;

    await this.page.click(radioSelector);
    await this.selectStartTime();
    await this.buttonCreate.click();
  }

  /**
   * The `selectWeekly` method generates the random values and performs the actions on the page in the weekly option of the parameter module
   * @author Gilber Cuadrado
   * @since 23/10/2024
   * @version 1.0
   */

  async selectWeekly(): Promise<void> {
    const daysToSelect = new Set<number>();
    const totalDays = this.dayCheckbox.length;
    while (daysToSelect.size < Math.floor(Math.random() * totalDays) + 1) {
      daysToSelect.add(Math.floor(Math.random() * totalDays));
    }
    for (const index of daysToSelect) {
      await this.dayCheckbox[index].click();
    }
    await this.selectStartTime();
    await this.buttonCreate.click();
  }

  /**
 * The `dataMonth` method generates the random values and performs the actions on the page in the monthly option of the parameter module
 * @author Gilber Cuadrado
 * @since 23/10/2024
 * @version 1.0
 */

  async dataMonth(): Promise<void> {
    let radioValuesType: string[];
    let randomValue: any;
    let radioId: any;
    let radioSelector: string;

    radioValuesType = Object.keys(parameterizationConfig.radioButtonTypeIdMonth);
    randomValue = radioValuesType[Math.floor(Math.random() * radioValuesType.length)];
    radioId = parameterizationConfig.radioButtonTypeIdMonth[randomValue];
    radioSelector = `${radioId}`;
    await this.page.click(radioSelector);

    switch (randomValue) {
      case "dayOfEachCheck": {
        const randomValueDays = this.getRandomValue(30);
        const randomValueMonth = this.getRandomValue(12);

        await this.selectRandomOption(this.monthFirstRowSelectDay, randomValueDays)
        await this.selectRandomOption(this.monthFistRowSelectMonth, randomValueMonth);
        await this.selectStartTime();
        await this.buttonCreate.click();

        break;
      }
      case "theOfEachCheck": {
        const randomValueMonths = this.getRandomValue(12);
        const randomWeekIndex = Math.floor(Math.random() * parameterizationConfig.weeks.length);
        const randomWeek = parameterizationConfig.weeks[randomWeekIndex];
        const randomDayIndex = Math.floor(Math.random() * parameterizationConfig.days.length);
        const randomDays = parameterizationConfig.days[randomDayIndex];

        await this.selectRandomOption(this.monthSecondRowSelectSequence, randomWeek)
        await this.selectRandomOption(this.monthSecondRowSelectDaysWeek, randomDays)
        await this.selectRandomOption(this.monthSecondRowSelectMonth, randomValueMonths)
        await this.selectStartTime();
        await this.buttonCreate.click();
        break;
      }
      default: {
        throw new Error("No valid option has been selected");
      }
    }
  }


  /**
 * The `dataYearly` method generates the random values and performs the actions on the page in the yearly option of the parameter module
 * @author Gilber Cuadrado
 * @since 23/10/2024
 * @version 1.0
 */

  async dataYearly(): Promise<void> {
    let radioValuesType: string[];
    let randomValue: any;
    let radioId: any;
    let radioSelector: string;

    const radioButtonTypeId = {
      ofEachCheck: LocatorsParameterization.programPeriodicity.yearly.eachCheck,
      theOfEachCheck: LocatorsParameterization.programPeriodicity.yearly.theOfEachCheck,
    };
    radioValuesType = Object.keys(radioButtonTypeId);
    randomValue = radioValuesType[Math.floor(Math.random() * radioValuesType.length)];
    radioId = radioButtonTypeId[randomValue];
    radioSelector = `${radioId}`;
    await this.page.click(radioSelector);

    switch (randomValue) {
      case "ofEachCheck": {
        const randomMonthsIndex = Math.floor(Math.random() * parameterizationConfig.months.length);
        const randomMonths = parameterizationConfig.months[randomMonthsIndex];
        const randomValueDays = this.getRandomValue(30);

        await this.selectRandomOption(this.yearlyFirstRowSelectMonth, randomMonths);
        await this.selectRandomOption(this.yearlyFirstRowSelectDay, randomValueDays);
        await this.selectStartTime();
        await this.buttonCreate.click();

        break;
      }
      case "theOfEachCheck": {
        const randomMonthsIndex = Math.floor(Math.random() * parameterizationConfig.months.length);
        const randomMonths = parameterizationConfig.months[randomMonthsIndex];
        const randomWeekIndex = Math.floor(Math.random() * parameterizationConfig.weeks.length);
        const randomWeek = parameterizationConfig.weeks[randomWeekIndex];
        const randomDayIndex = Math.floor(Math.random() * parameterizationConfig.days.length);
        const randomDays = parameterizationConfig.days[randomDayIndex];

        await this.selectRandomOption(this.yearlySecondRowSelectSequence, randomWeek);
        await this.selectRandomOption(this.yearlySecondRowSelectDayWeek, randomDays);
        await this.selectRandomOption(this.yearlySecondRowSelectMonth, randomMonths);

        await this.selectStartTime();
        await this.buttonCreate.click();
        break;
      }
      default: {
        throw new Error("No valid option has been selected");
      }
    }
  }

  /**
 * The Method `randomSelectPeriodicity` is in charge to generate the periodicity options randomly.
 * @author Gilber Cuadrado
 * @since 23/10/2024
 * @version 1.0
 */

  async randomSelectPeriodicity(): Promise<void> {
    let totalOptionsPeriodicity: number;
    let randomIndex: number;
    let selectedOption: any;

    totalOptionsPeriodicity = this.optionsPeriodicity.length;
    randomIndex = Math.floor(Math.random() * totalOptionsPeriodicity);
    await this.optionsPeriodicity[randomIndex].click();
    selectedOption = parameterizationConfig.optionMap[randomIndex];

    switch (selectedOption) {
      case "Minutos":
        await this.selectMinutesRandom();
        break;

      case "Cada hora":
        await this.selectEachHour();
        break;

      case "Diario":
        await this.dataDiary();
        break;

      case "Semanal":
        await this.selectWeekly();
        break;

      case "Mensual":
        await this.dataMonth();
        break;

      case "Anual":
        await this.dataYearly();
        break;

      default:
        throw new Error("Selected option not recognized");
    }
  }


}
